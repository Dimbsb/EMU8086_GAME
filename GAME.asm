; The below programm aims at creating a game with VGA graphics in which the screen
; will be divided into a grid of 3x3 rectangles, and randomly select a rectangle
; Also, the color of the rectangle wiil be changed randomly for 1 sec 
; Then it will turn black and another one (maybe the same) will be selected with random color 
; If the user presses 'q' the execution will stop (=exit) 
; If the user presses 'spacebar' there will be a pause until he presses 'spacebar' again
; After compiling the code an .exe file is created which is about to be executed in dosbox which will run the code at full speed
; In this way we avoid slowness of emu8086

; The main logic of this programm is divided into the below parts
; Firstly we create a 3x3 grid
; Then 9 rectangles are created
; Then we randomly paint one of these at a time 
; The PAINT procedure generates a random color and then paints a rectangle of 105 pixels wide and 66 pixels height
; This procedure is done at a given screen position (That we have setted up (9 positions))
; Then we wait for a second
; Then in order to erase the rectangle we just paint it black in a separate procedure... and so on...
; The program checks for keypresses to toggle between running and paused states ('spacebar' key) or to quit the program ('q' key).

; Declaring the variables needed
DATA SEGMENT
    COUNTER DW 0                     ; Counter so as to paint with (color or black) all the pixels of the rectangle 
    POSSIBLE_POSITIONS DW 9 DUP(?)   ; Create an array so as to store the 9 rectangle positions
    PAUSED DW 0                      ; Flag to track the pause state (0 = running, 1 = paused)
    SEED DW ?                        ; Initial seed for the PRNG (random number generator)
    DEBUG_OUTPUT DW ?                ; For debugging: stores the random value generated by rnd16
DATA ENDS


CODE SEGMENT
START:
    MOV AX, DATA
    MOV DS, AX   
    MOV ES, AX

; Initialize the seed using the system timer
    MOV AH, 0
    INT 1Ah               ; Get system time (CX:DX contains the timer tick count)
    MOV SEED, DX          ; Use DX (lower 16 bits of the timer) as the seed

; Call the functions
    CALL SETGRAPHICSMODE   ; Set graphics mode 
    CALL CREATEBORDERS     ; Create grid
    CALL POSITIONS         ; Positions - blinking

    MOV AH, 4Ch            ; Exit program
    INT 21h

; 13h - graphical mode. 40x25. 256 colors. 320x200 pixels. 1 page.         
SETGRAPHICSMODE PROC
    PUSH AX
    MOV AL, 13h 
    MOV AH, 0h         
    INT 10h
    POP AX     
    RET
SETGRAPHICSMODE ENDP


CREATEBORDERS PROC
    PUSHA 
    MOV BX, 0A000h         ; Set ES to point to the video memory segment
    MOV ES, BX  
             
;Horizontal borders (320 pixels width)
    MOV CX, 320
    MOV DI, 0
HORIZONTAL:           
    MOV ES:[DI], 13          ; Top border, color 13 (color = light magenta)
    INC DI        
    MOV ES:[DI + 21120], 13  ; Middle border (row 66)
    MOV ES:[DI + 42240], 13  ; Middle border (row 133)
    MOV ES:[DI + 63680], 13  ; Bottom border (row 199)
    LOOP HORIZONTAL  
    
; Vertical borders (200 pixels height)
    MOV CX, 200
    MOV DI, 0 
VERTICAL:
    MOV ES:[DI], 13          ; Left border, color 13 (color = light magenta)
    MOV ES:[DI + 106], 13    ; Vertical line at position 106
    MOV ES:[DI + 212], 13    ; Vertical line at position 212
    MOV ES:[DI + 319], 13    ; Right border
    ADD DI, 320
    LOOP VERTICAL     
        
    POPA
    RET
CREATEBORDERS ENDP
 
               
POSITIONS PROC
    PUSHA
    
; Initialize possible positions for rectangles (9 starting Positions)
    MOV WORD PTR [POSSIBLE_POSITIONS+0], 1*320  
    MOV WORD PTR [POSSIBLE_POSITIONS+2], 1*320 + 106
    MOV WORD PTR [POSSIBLE_POSITIONS+4], 1*320 + 212 
    MOV WORD PTR [POSSIBLE_POSITIONS+6], 67*320 
    MOV WORD PTR [POSSIBLE_POSITIONS+8], 67*320 + 106
    MOV WORD PTR [POSSIBLE_POSITIONS+10], 67*320 + 212
    MOV WORD PTR [POSSIBLE_POSITIONS+12], 133*320 
    MOV WORD PTR [POSSIBLE_POSITIONS+14], 133*320 + 106
    MOV WORD PTR [POSSIBLE_POSITIONS+16], 133*320 + 212 

BLINK_LOOP:
; Generate a random number between 0 and 8 (9 positions)
    CALL rnd16
    MOV DX, 0
    MOV CX, 9
    DIV CX
    MOV AX, DX

; Store random value for debugging
    MOV [DEBUG_OUTPUT], AX

; Multiply by 2 to get the offset in POSSIBLE_POSITIONS
    SHL AX, 1
    MOV SI, AX

; Get the position based on the random index
    MOV DI, WORD PTR [POSSIBLE_POSITIONS + SI]

; Paint the rectangle at this position
    CALL PAINT

; Delay for 1 second
    MOV CX, 0FH
    MOV DX, 2120H
    MOV AH, 86H
    INT 15H

; Erase the rectangle by painting it black
    CALL BLACK

; Check for key press
    MOV AH, 01h
    INT 16h
    JZ BLINK_LOOP  ; If no key pressed, continue blinking

    ; If key is pressed, check which key
    MOV AH, 00h
    INT 16h
    CMP AL, 'q'    ; Quit on 'q'
    JE EXIT_LOOP
    CMP AL, ' '    ; Toggle pause on spacebar
    JNE BLINK_LOOP
    
    XOR WORD PTR [PAUSED], 1    ; Toggle the pause state

; Pause loop
PAUSE_LOOP:
    MOV AH, 01h
    INT 16h
    JZ PAUSE_LOOP  ; Wait for another key press to unpause
    MOV AH, 00h
    INT 16h
    CMP AL, ' '    ; Unpause on spacebar
    JNE PAUSE_LOOP
    
    XOR WORD PTR [PAUSED], 1    ; Toggle the pause state back and resume

    JMP BLINK_LOOP

EXIT_LOOP:
    POPA
    RET
POSITIONS ENDP

; Function to paint the rectangle with color                          
PAINT PROC
    PUSHA

; Generate a random color in AX
    CALL rnd16
    MOV AL, AH   ; Use the higher byte of AX as the random color (0-255)

    MOV CX, 105  ; Width of the rectangle (105 pixels)
ALLCOLOR:
    INC DI       ; Move to next pixel
    MOV BX, DI   ; Set BX to the current pixel location
    MOV COUNTER, 1

COUNTER_LOOP_COLOR:
    MOV ES:[BX], AL  ; Paint the pixel with the random color
    ADD BX, 320      ; Move to the next row (320 pixels down)

    INC COUNTER
    CMP COUNTER, 66  ; Draw 66 rows (height of the rectangle)
    JL COUNTER_LOOP_COLOR

    LOOP ALLCOLOR  
    
    POPA
    RET
PAINT ENDP

; Random seed function
RND16 PROC
    MOV AX, SEED      ; Load the current seed from memory
    MOV DX, 8403H     ; Multiplier (a constant used in the linear congruential generator)
    MUL DX            ; Multiply AX (the seed) by the constant multiplier (result in DX:AX)
    INC AX            ; Add 1 to AX (increment, as part of the linear congruential algorithm)
    MOV SEED, AX      ; Store the new seed back in memory for future use
    RET
RND16 ENDP

; Erase the painted rectangle
; Practically the paint procedure...But with selected color black
BLACK PROC
    PUSHA
    
    MOV CX, 105  ; Number of horizontal steps (width of the rectangle)
ALLBLACK:
    INC DI       ; Move to the next pixel in the row
    MOV BX, DI   ; Load the current pixel address into BX
    MOV COUNTER, 1

COUNTER_LOOP_BLACK:
    MOV ES:[BX], 00  ; Set the pixel to black (color 0)
    ADD BX, 320      ; Move to the next row (320 pixels down)

    INC COUNTER
    CMP COUNTER, 66  ; Continue drawing until 66 rows are drawn (height of the rectangle)
    JL COUNTER_LOOP_BLACK

    LOOP ALLBLACK
    
    POPA
    RET
BLACK ENDP


CODE ENDS  

STACK SEGMENT
    DW 128 dup(0)   ; Reserve 128 words for the stack
STACK ENDS


END START